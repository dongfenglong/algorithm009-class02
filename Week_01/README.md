# Go语言数组和切片

Go语言的数组、切片在底层原始数据有着相同的内存结构，因为语法的限制而有着不同的行为表现。

## 1. Go语言变量的赋值和传参

Go语言的赋值和函数传参规则很简单，除了闭包函数以引用的方式对外部变量进行访问之外，其它赋值和函数传参都是以**<u>传值</u>**的方式处理。

首先， Go语言的数组是一种**值类型**， 虽然数组的元素可以被修改， 但是数组本身的赋值和函数传参都是以整体复制的方式处理的。  

其次，Go语言字符串底层数据也是对应的字节数组。字符串赋值是将头信息部分按照传值方式处理，只复制了数据地址和对应的长度

切片的赋值和函数传参也是将切片头信息部分按照传值方式处理。因为切片头部含有底层数据的指针，所以他的复制也不会导致底层数据的复制。

<u>**数据的传值是Go语言编程的一个哲学， 虽然传值有一定的代价， 但是换取的好处是切断了对原始数据的依赖 。**</u>



## 2. 数组

首先，Go语言的数组是值语义，<u>一个数组变量即表示整个数组</u>，它并不是隐式的指向第一个元素的指针（比如C语言的数组），而是一个**完整的值**。

虽然数组元素可以被修改，但是数组本身的赋值、函数传参都是以整体复制的方式处理的。为了避免复制带来的开销，可以使用指向数组的指针。注意，数组指针不是数组。



因为在Go语言中，数组的长度是数组类型的组成部分，所以不同长度或不同类型的数据组成的数组都是不同的类型，互相之间不能直接赋值。

此时，就可以将数组看做一个特殊的结构体，结构的字段名对应数组的索引。

内置函数len、cap分别计算数组的长度和容量，不过len和cap返回的结果始终一致，都是对应数组类型的长度。



## 3. 切片

切片是可以动态增长和收缩的序列，是简化版的动态数组。

因为动态数组的长度不固定，所以切片的长度自然也就不能是类型的组成部分了。

切片的结构定义(reflect.SliceHeader)：

```go
type SliceHeader struct {
	Data uintptr	//切片指向底层数组的指针
	Len  int		//切片的长度
	Cap  int		//切片的容量
}
```



Go语言内置的泛型函数`append`可以在切片的尾部追加 1 ~ N 个元素。

不过，在容量不足的情况下，`append`操作会导致重新分配内存，可能导致巨大的内存分配和数据迁移开销。

即使容量足够，依然要使用`append`函数的返回值来更新切片本身，因为新切片的长度已经发生了变化。



除了在切片尾部追加元素，还可以在切片头部添加元素。

```go
x := []int{1, 2, 3}
x = append([]int{0}, x...)
```

<u>**在开头一般都会导致内存的重新分配，而且会导致已有的元素全部复制 1 次。**</u>

因此，从切片的开头添加元素的性能一般要比从尾部追加元素的性能差很多。



因为`append`函数返回新的切片，所以它支持链式操作。

通过链式操作，我们可以实现切片中间插入元素。

```go
var x []int
x = append(x[:i], append([]int{s}, x[i:])) 			//在第 i 个位置插入 s
x = append(x[:i], append([]int{1, 2, 3}, x[i:]))	//在第 i 个位置插入切片
```

每个添加操作中的第二个`append`都会返回一个临时切片，并将`x[i:]`的内容复制到这个临时切片，然后再将这个临时切片追加到`x[:i]`。

可以用`copy`和`append`组合，避免创建中间的临时切片。

```go
x = append(x, 0)		//切片扩展 1 个空间
copy(x[i+1:], x[i:])	//a[i:]向后移动一个位置
x[i] = s				//设置新添加的元素
```



删除切片元素

根据元素的位置，分为三种情况：从开头位置删除，从中间位置删除，从尾部删除。

其中删除尾部的元素最快。

```go
a := []int{1, 2, 3}
a = a[:len(a)-1]	// 删除尾部1个元素
a = a[:len(a)-N]	// 删除尾部N个元素
```

删除开头的元素可以直接移动数据指针：

```go
a := []int{1, 2, 3}
a = a[1:]	// 删除开头1个元素
a = a[N:]	// 删除开头N个元素
```

删除中间元素，需要对后续元素进行整体前移，用`append` 或 `copy` 完成：

```go
a := []int{1, 2, 3}
a = append(a[:i], a[i+1:]...)	// 删除中间1个元素
a = append(a[:i], a[i+N:]...)	// 删除中间N个元素
```

切片高效操作的要点是<u>降低内存分配的次数</u>，尽量保证`append`操作不会超出`cap`的容量，尽量避免触发内存分配，同时降低每次分配内存的大小。





# 学习笔记

## 一、数据结构与算法总览

### 1. 数据结构

### 2. 思考题

1. 二叉树遍历——前序、中序、后序：时间复杂度分别是多少？

    都是O(n)

    因为二叉树遍历不管是前序、中序、后序，都会访问二叉树的每一个节点，并且只访问一次，因此时间复杂度是O(n)

2. 图的遍历：时间复杂度是多少？

    O(n)

    图的每个节点都会访问，并且只访问一次，因此时间复杂度也是O(n)

3. 搜索算法：DFS和BFS的时间复杂度呢？

    O(n)

    n代表搜索空间里面的节点总数

4. 二分查找：时间复杂度是多少？

    O(logn)



## 三、数组、链表、跳表

### 1. 链表操作的时间复杂度

| 操作    | 效果         | 时间复杂度 |
| ------- | ------------ | ---------- |
| prepend | 头部增加元素 | O(1)       |
| append  | 尾部追加元素 | O(1)       |
| lookup  | 查找元素     | O(n)       |
| insert  | 插入元素     | O(1)       |
| delete  | 删除元素     | O(1)       |



### 2. 数组操作的时间复杂度

| 操作    | 效果         | 时间复杂度 |
| ------- | ------------ | ---------- |
| prepend | 头部追加元素 | O(1)       |
| append  | 尾部追加元素 | O(1)       |
| lookup  | 查找元素     | O(1)       |
| insert  | 插入元素     | O(n)       |
| delete  | 删除元素     | O(n)       |



### 3. 跳表

1. 给链表加速的优化思想：

    升维，或者说空间换时间

    方法：

    ​	添加一级或多级索引

    实现：

    ​	跳表，时间复杂度O(logn)，空间复杂度O(n)

    



## 四、栈、队列、双端队列、优先队列

### 1. 栈 Stack

​	First In Last Out

​	添加、删除	O(1)

​	查询			  O(n)



### 2. 队列 Queue

​	First In First Out

​	添加、删除	O(1)

​	查询			  O(n)



### 3. 双端队列 Deque

​	Double-End Queue

​	两端都可以进出的Queue

​	添加、删除	O(1)

​	查询			  O(n)



### 4. 优先队列 Priority Queue

​	插入		O(1)

​	取出		O(logn)	按照优先级取出元素

​	底层实现的数据结构较为多样和复杂，有 heap、bst（bianry search tree）、treap





























